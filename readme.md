# TIL : Git
Today I learned git.


## gitって何？
分散型バージョン管理システム。\
プロジェクトのファイル・ディレクトリの状態を、ひとつの"リビジョン"として記録できる（リビジョンという言葉は、ほぼバージョンと同じだと考えればいい）。\
ファイル・ディレクトリの状態は記録したリビジョンに切り替えられるので、過去のリビジョンはどんな状態だったのか確認・比較する、特定の過去のリビジョンから別のリビジョンを派生させる、などといったことが簡単にできる（バージョン管理システム）。\
\
gitの管理対象（プロジェクトと、そのリビジョンの履歴など）のまとまりをリポジトリと呼ぶ。\
プロジェクトに参加するメンバは、サーバに置いたリポジトリをローカルにコピーし、それぞれで作業を進める。\
作業の成果物として記録したリビジョンは、任意のタイミングで他のメンバと共有できる。これにより複数メンバでひとつのプロジェクトを同時並行的に進めることが可能（分散型）。\
\
例えば以下のようなときにgitが役立つ。
* 複数のメンバ共同で開発を進めたい。
* 細かい単位で更新していきたい。
* 過去のある時点での、プロジェクトがどんな状態だったのかを知りたい・確認したい。
* 過去のバージョンを復旧したい。


## インストール方法
google参照。


## 支援ツール
gitはCLIで使う他、GUIで操作できるツールもある。[`Sourcetree`](https://www.google.co.jp/)とか。\
vscodeの`Git Graph`拡張機能も便利。


## 使い方（ざっくり）
ざっくりとした使い方としては、
1. リポジトリを作る or サーバにあるリポジトリをコピーしてくる
2. ソースコードを更新する
3. ソースコードの更新がきりのいいところまで進んだら、そのリビジョンを保存する。
4. 他の人と共有できるところまで進んだら、そのリビジョンを共有する。
5. 他の人の更新を取り込む
6. 2から5を繰り返す

「コピーする」「リビジョンを保存する」といった操作は、支援ツールを使うなりコマンドを使うなりして行う。


## ローカルな範囲での操作
リポジトリを作ってからリビジョンを保存するまで。

### init
リポジトリを作る。\
現ディレクトリ以下をgitの管理化に置くイメージ。
```sh
$ git init
```

### clone
サーバにあるリポジトリをローカルにコピーする。gitではコピーとはいわず、クローンという。
```sh
$ git clone <リポジトリのアドレス>
```

### branch
gitを使いつつプロジェクトを更新していくときは「リビジョンを積み上げる」というイメージを持つといい。\
つまり、あるリビジョンに対して更新することで次のリビジョンを作る。そのリビジョンに対して……というのを繰り返していく。
```
[rev.1] -(更新内容を足す)-> [rev.2] -(更新内容を足す)-> [rev.3]
```
このようにして、リビジョンが繋がっていくことで、一本の長い線になっていく。\
実際には、この線は一本でなければならない、ということはない。あるリビジョンに対して異なる更新内容を足して、更新の線を分岐させることができる。
```
[rev.A1] --> [rev.A2] --> [rev.A3] # branch_A
         \
          \-> [rev.B1] --> [rev.B2] # branch_B
                        \
                         \-> [rev.C1] --> [rev.C2] # branch_C
プロジェクトの進展 ----------------------------->
```
この更新の線（履歴）をブランチという。更新を足してブランチを伸ばしていくというイメージ。\
（この説明は正しくない。更新の線 = ブランチというイメージの方が直感的だし、初めは解りやすいと思う。より正しい説明は[ブランチとは何か](branch.md)）。
リビジョンを作るには、まずブランチの名前を決めなければならない。
```sh
$ git branch <ブランチの名前> # 現在のリビジョンを起点としたブランチの名前をつける
```

### checkout
これからリビジョンを作ったとき、どのブランチを育てるかを切り替える。\
ブランチを切り替えるとリビジョンも変わる。リビジョンはそのブランチの先頭のものになり、ファイルの内容も変化する。
```sh
$ git checkout <ブランチの名前>
```

### add
ファイルの更新内容をリビジョンとして保存するには、まず保存対象の候補として選ばなくてはならない。この「候補として選ぶ」ことを「ステージング」という。\
ステージングの対象はファイルではなく、ファイルの更新内容。
```sh
$ git add <ファイルパス> # ファイルパスは複数指定可能
$ git add . # 変更のあったファイルの更新内容を全てステージングする
```

### commit
ステージングされた更新内容をリビジョンとして保存し、ブランチを伸ばす。\
更新内容をリビジョンとして保存することを、コミットという。
```sh
$ git commit -m <コメント>
```

## ローカルとサーバのやり取り
他の人と自前のリビジョンを共有したり、他の人が作ったリビジョンを取り込んだりする。

### remote
`git init`でリポジトリを作った場合、他の人とリポジトリを共有するためには、まず共有のサーバを指定しなくてはならない。正確には、共有するリポジトリ（リモートリポジトリ）の置き場所をURLの形で指定する必要がある。
```sh
$ git remote add <リモートリポジトリの名前> <リモートリポジトリのURL>
```
`リモートリポジトリの名前`は識別のためのもので、任意に決めて良い(よく使われる名前はorigin)。\
`リモートリポジトリのURL`にはhttpプロトコルの他に、gitプロトコルも使える。\
最初にサーバにあるリポジトリをクローンしてきた場合は`git remote add`しなくても良い。\
\
リモートリポジトリに関する他のコマンドとしては、
```sh
$ git remote show # addしたリモートリポジトリ一覧
$ git remote get-url <リモートリポジトリの名前> # リモートリポジトリのURLを確認する
$ git remote remove <リモートリポジトリの名前> # リモートリポジトリの登録を削除する
```
`git remote remove`はリモートリポジトリを削除するのではなく、`リモートリポジトリの名前`とリモートリポジトリの紐付けを解除する（ローカルから削除するだけでリモートには影響しない）。

### push
ローカルのブランチをリモートリポジトリに送信する。
```sh
$ git push <リモートリポジトリの名前> <ブランチの名前>
```

### fetch
リモートリポジトリに更新がないか確認する。他の人が更新した分があるかもしれない。
```sh
$ git fetch
```

### pull
リモートリポジトリの更新をローカルのリポジトリに取り込む。普通は`fetch`で各ブランチに更新がないかどうかを確認し、更新があったら`pull`で取り込めばいい。
```sh
$ git pull <リモートリポジトリの名前> <ブランチ名>
```
`pull`を使うと、今いるブランチと<ブランチ名>で指定されたブランチの差分が、今いるブランチに追加される。より正しくは、今いるブランチに<ブランチ名>のブランチが[`merge`](#merge)される。\
`pull`を使うときは今いるブランチと、取り込むブランチを合わせておくのが良い(hogeブランチをpullしたいなら、hogeブランチをcheckoutした状態にしておく)。


## ブランチをまとめる
ブランチの作り方については、特に遵守しなくてはならないルールはない。リモートに上げるブランチについてはプロジェクトによってルールを設けることもあるが、しかしローカルのブランチについては開発者個人の裁量でどんな風に作っても良いだろう。\
ただ、一般的にはブランチごとに何らかの役目を持たせるのが普通である。例えばmainブランチはリリース用（mainブランチ上にあるリビジョンは常にリリースするバージョン）、developブランチは開発途中のもの、fugaブランチは或る機能を開発するためのもの、など。\
ブランチとは[分岐された更新の履歴](#branch)であるが、分岐後、他のブランチに合流させることができる。つまり、mainブランチからdevelopブランチを分岐させ、developブランチを伸ばしていき、リリースできるまで伸びたらmainブランチに合流させ、mainブランチの成果物をリリースする、というような作業の流れを作ることができる。

例えば、以下のようにmainブランチとdevelopブランチがあるとする。
```
[rev.main1] --> [rev.main2] # main
         \
          \-> [rev.develop1] # develop

プロジェクトの進展 ----------------->
```

rev.mainA2の変更もrev.develop1の変更も、どちらも採用したい場合には、この2つのブランチを合流させれば良い。

### merge
2手に分かれているブランチを1つにまとめる方法のひとつとして`merge`がある。\
これは、現在のブランチに、他のブランチを引き込む作業である。イメージとしては下図の通り。

```
[rev.main1] --> [rev.main2]-------------->[rev.main3] # main
         \                                  / # <- merge!!
          \-> [rev.dev1] --> [rev.dev2] -->/ # develop

プロジェクトの進展 ----------------------------------->
```

(merge以前に)rev.main1に対して行われた更新は、rev.main2、rev.dev1、rev.dev2の3つ。この3つの更新をひとつにまとめるような更新を行うrev.main3を、mainブランチとして`commit`し、更にdevelopブランチは変更しないというのが`merge`である。

```sh
$ git merge <取り込みたいブランチ名>
```

### rebase
### pull request(merge request)

## コミットのやり直し
### reset
### revert

## 便利機能
### tag
### stash

